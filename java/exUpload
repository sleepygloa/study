
package vertexid.paragon.comm.util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;

import paragon.core.paramaters.Params;
import paragon.core.paramaters.datatable.DataTable;

/**
 * [설명]
 *
 * @class CommExcel.java
 * @package vertexid.paragon.comm.util
 * @author "Kim Jin Ho"
 * @version 1.0
 */
public class CommExcel {
	private static final Log LOG = LogFactory.getLog(CommExcel.class);
	private static final String SP = File.separator;	// 서버 구분자
	private static final String BASEFOLDER = "upload";		// 기본폴더명
	public static String savePath = "";
	
	
	@Autowired(required = true)
//	private  HttpServletRequest request;
	
	
	//엑셀 다운로드
	public String makeAndDownload(HttpServletResponse response,  HttpServletRequest request, Params inParams) throws Exception {
	   	
		DataTable dt = inParams.getDataTable();
		String sheetName = inParams.getString("sheetNm");
		List<String> columnNms = inParams.getStrListParam("columnNms"); 
		List<String> columnIds = inParams.getStrListParam("columnIds");
		String caption = inParams.getString("caption");
		
		LOG.debug("inParams : "  + inParams);
//		LOG.debug("columnNms : "  + columnNms);
		
		XSSFWorkbook workbook = new XSSFWorkbook();
		// 2차는 sheet생성
		if(sheetName == null){
			sheetName = "sheet";
		}
		XSSFSheet sheet = workbook.createSheet(sheetName);
		
		// 엑셀의 행
		XSSFRow row = null;
		// 엑셀의 셀
		XSSFCell cell = null;
		// 임의의 DB데이터 조회
		
		
		XSSFCellStyle cellStyle_head = workbook.createCellStyle();
		cellStyle_head.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
		cellStyle_head.setBorderRight(HSSFCellStyle.BORDER_THIN);   
		cellStyle_head.setBorderLeft(HSSFCellStyle.BORDER_THIN);   
		cellStyle_head.setBorderTop(HSSFCellStyle.BORDER_THIN);   
		cellStyle_head.setBorderBottom(HSSFCellStyle.BORDER_THIN);
//		cellStyle_head.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
		cellStyle_head.setAlignment((short)2);
		
		XSSFCellStyle cellStyle_body = workbook.createCellStyle();
	    cellStyle_body.setBorderRight(HSSFCellStyle.BORDER_THIN);   
	    cellStyle_body.setBorderLeft(HSSFCellStyle.BORDER_THIN);   
	    cellStyle_body.setBorderTop(HSSFCellStyle.BORDER_THIN);   
	    cellStyle_body.setBorderBottom(HSSFCellStyle.BORDER_THIN); 
		
	    int rowNum = 0; //시작행 초기화
	    int rowWidthPadding = 256;
	    
	    
	  //병합 영역 설정
/*			row = sheet.createRow((short) rowNum);
			for (int i = 0; i < columnIds.size(); i++) {
				cell = row.createCell(i);
			    cell.setCellValue(String.valueOf(caption));
			}
		    sheet.addMergedRegion(new CellRangeAddress(rowNum,rowNum,rowNum,columnIds.size()-1));
		    rowNum += 1;*/
	    //제목컬럼
		row = sheet.createRow((short) rowNum);
		for (int i = 0; i < columnIds.size(); i++) {
			LOG.debug("columns  :  "+String.valueOf(columnNms.get(i)));			
			cell = row.createCell(i);
			cell.setCellValue(String.valueOf(columnNms.get(i)));
			cell.setCellStyle(cellStyle_head);
			if(i == columnIds.size()){
				rowNum += 1;
			}
		}
		//내용
		for (int i = 1; i <= dt.size(); i++) {
			row = sheet.createRow((short) i+rowNum);
			for (int f = 0 ; f < columnIds.size(); f++) {
				cell = row.createCell(f);
//				LOG.debug("list.get(f) : " + columnIds.get(f));
//				LOG.debug("dt.get : " + dt.get(i-1).getString(columnIds.get(f)));
				if("null".equals(String.valueOf(dt.get(i-1).getString(columnIds.get(f))))){ //null -> ""
				    cell.setCellValue("");
				}else{
				    cell.setCellValue(String.valueOf(dt.get(i-1).getString(columnIds.get(f))));
				}
				cell.setCellStyle(cellStyle_body);				
			}
		}
		//셀크기 자동조정
		for (int i=0;i<columnIds.size();i++) //autuSizeColumn after setColumnWidth setting!! 
		{ 
		sheet.autoSizeColumn(i);
		sheet.setColumnWidth(i, (sheet.getColumnWidth(i))+rowWidthPadding ); 
		}
		
//		workbook.getSheetAt(0).setDefaultColumnWidth(20000);
//		for (int i = 0; i < columnNms.size(); i++) {
//			workbook.getSheetAt(0).autoSizeColumn(i);
//		}
		String root = request.getSession().getServletContext().getRealPath("/");
		String fullPath = uploadServer("excel"+SP+"grid",root);
		
		FileOutputStream fileoutputstream = null;
		// 파일을 쓴다
		try {
			fileoutputstream = new FileOutputStream(fullPath);
			workbook.write(fileoutputstream);
			fileoutputstream.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return fullPath;
	}

	
	private String uploadServer(String folder , String root){
//		String folder = "doc";
		String date = new SimpleDateFormat("yyyyMMddhhmmssSSS").format(new Date());
		String dirY = new SimpleDateFormat("yyyy").format(new Date()); 
		String dirM = new SimpleDateFormat("MM").format(new Date()); 
		String dirD = new SimpleDateFormat("dd").format(new Date()); 
		

		String sFileName = "grid_"+date +".xlsx";
//		String root = request.getSession().getServletContext().getRealPath("/");
//		String root = "D:\\";
		String filePath =  root +BASEFOLDER+SP+folder +SP+ dirY+SP+ dirM+SP+ dirD ;
		savePath = "/"+BASEFOLDER+"/"+folder+"/"+dirY+"/"+dirM+"/"+dirD;

		FileOutputStream fos = null;
		String fullPath = "";
		try {
			sFileName = checkFile(filePath,sFileName);
			fullPath = filePath + SP + sFileName;
			checkDir(filePath);
//			fos = new FileOutputStream(fullPath);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (fos != null) {
				try {
					fos.close();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		return fullPath;
	}
	private void checkDir(String path) {
		File dir = new File(path);
		if (!dir.exists()) {
			dir.mkdirs();
		}
	}
	
	
	private String checkFile(String path, String fileNm){
		String tempFileName =  fileNm.substring(0,fileNm.lastIndexOf("."));
		String tempFileEx =  fileNm.substring(fileNm.lastIndexOf("."));
		String tempFullName =  tempFileName+tempFileEx;
		int cnt = 1;
		while (true) {
			File f = new File(path+SP+tempFullName);
			if (f.isFile()) {
				System.out.println(tempFullName+ "와 동일한 파일명이 있습니다.");
				tempFullName = tempFileName+"("+cnt+")"+tempFileEx;
				cnt++;
			}else {
				System.out.println(tempFullName + "는 등록된 파일이 없습니다.");
				break;
			}
	    }
	    return tempFullName;
	}
	
	//엑셀업로드/////////////////////////////////////////////////////////////////////////////////////////////////
    private Map<String, Integer> exDataMap = null;
	private ExcelReadOption excelReadOption = null;
	private Workbook wb = null;
	private Sheet sheet = null;
	private int sheetNum = 0;   //시트 번호
	private Row row = null;
	private Cell cell = null;
	private int numOfCells = 0; //컬럼의 개수
	private int numOfRows = 0; //로우의 개수
	public String cellName = ""; //컬럼 이름, 작업중인 컬럼 이름
	private String columnNmStr = ""; //Log용
	public int rowIndex = 0; //작업중인 행 번호
	public int colIndex = 0; //작업중인 열 번호
	private String validationColor = "f95df1cf"; //컬럼의 필수값 배경색
	private List valiColList = new ArrayList();
	
	private Map<String, String> colMapping = null;
	
	
	public Map<String, String> excelFileColumnMapping(HttpSession session, MultipartHttpServletRequest request) throws NullPointerException, IOException{
        MultipartFile excelFile = request.getFile("excelFile");
		LOG.debug("===== 엑셀 업로드 시작 =====");
		
		//엑셀파일 존재여부 파악
        if(excelFile == null || excelFile.isEmpty()){
            throw new IOException();
        }
        
        //초기화
        File destFile = new File(session.getServletContext().getRealPath(excelFile.getOriginalFilename()));
        excelFile.transferTo(destFile);
        
        exDataMap = new HashMap<String, Integer>();
        setExDataMap("setLoadingSheetNum", 0); //시트 번호
        setExDataMap("getColumnForCount", 1); //시작 컬럼
        setExDataMap("setLoadingColStCount", 0); //제목행 위치
        setExDataMap("setLoadingContStCount", 2); //데이터행 위치
        
        //엑셀 데이터를 읽기 위한 변수 설정
        excelReadOption = new ExcelReadOption();
        //0. Path
        excelReadOption.setFilePath(destFile.getAbsolutePath());
        //1. column 값
        excelReadOption.setStartRow(getExDataMap("setLoadingColStCount"));
            
        //엑셀 데이터 생성 (자바)
    	wb = getWorkbook(excelReadOption.getFilePath());
    	
//    	sheetNum = wb.getNumberOfSheets(); //시트의 개수를 가져오기 위한 변수 (전체시트)
    	sheetNum = getExDataMap("setLoadingSheetNum"); //한시트일때
    	sheet = wb.getSheetAt(sheetNum);         	
    	LOG.debug("Sheet Name = "+ wb.getSheetName(sheetNum));
    	
    	//유효한 데이터가 있는 행의 개수를 가져온다.
        numOfRows = sheet.getPhysicalNumberOfRows();
    	
        //컬럼이있는 행
        row = sheet.getRow(getExDataMap("setLoadingColStCount"));
        
		return readLogic();
	}
	
	//컬럼과 데이터 조회 두 로직에서 사용됨
	public Map<String, String> readLogic() throws NullPointerException{
		Map<String, String> returnExMap = new HashMap<String, String>();
		
		//컬럼의 개수
    	numOfCells = row.getPhysicalNumberOfCells();
    	 
    	//COLUMN 명 입력
    	for(int colIndexCount = 0; colIndexCount < numOfCells; colIndexCount++) {
    		colIndex = colIndexCount;
    		cell = row.getCell(colIndexCount);
    		cellName = ExcelCellRefGetName(cell, colIndexCount);	//해당 컬럼의 명을 입력.
        	if(colIndexCount != 0){
        		columnNmStr += ", ";
        	}
        	columnNmStr += cellName;
        	
        	//매핑, 컬럼일때 {A = DATA_COLUMN_NAME}, 데이터일때 {DATA_COLUMN_NAME = VALUE}
        	if(colMapping == null){
                returnExMap.put(cellName, ExcelCellRefGetValue(cell));
        	}else{
        		returnExMap.put(colMapping.get(cellName), ExcelCellRefGetValue(cell));
        	}
        }
		return returnExMap;
	}
	
    public List<Map<String, String>> read()throws NullPointerException {
        //FileType.getWorkbook() <-- 파일의 확장자에 따라서 적절하게 가져온다.
    	Map<String, String> returnExMap = new HashMap<String, String>();
        List<Map<String, String>> result = new ArrayList<Map<String, String>>(); 
        
        for(int rowIndexCount = getExDataMap("setLoadingContStCount"); rowIndexCount < numOfRows ; rowIndexCount++) {
            row = sheet.getRow(rowIndexCount);
            rowIndex = rowIndexCount+1;
            if(row != null) {
            	LOG.debug("rowIndex = "+rowIndex);
            	returnExMap = readLogic();
                result.add(returnExMap);   
            }
        }
    return result;       
	}      

	/** [엑셀 업로드 메서드]
	 * [설명] 엑셀파일을 읽어서 Workbook 객체에 리턴한다.
	 * [설명] XLS와 XLSX 확장자를 비교한다.
	 * 
	 * @Author "Kim Seon Ho"
	 * @Date 2017. 11. 24.
	 */
    public Workbook getWorkbook(String filePath) {
        
        /*
         * FileInputStream은 파일의 경로에 있는 파일을
         * 읽어서 Byte로 가져온다.
         * 
         * 파일이 존재하지 않는다면은
         * RuntimeException이 발생된다.
         */
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(filePath);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
        
        Workbook wb = null;
        
        /*
         * 파일의 확장자를 체크해서 .XLS 라면 HSSFWorkbook에
         * .XLSX라면 XSSFWorkbook에 각각 초기화 한다.
         */
        if(filePath.toUpperCase().endsWith(".XLS")) {
            try {
                wb = new HSSFWorkbook(fis);
            } catch (IOException e) {
            	LOG.debug(".XLS 로딩오류");
                throw new RuntimeException(e.getMessage(), e);
            }
        }
        else if(filePath.toUpperCase().endsWith(".XLSX")) {
            try {
                wb = new XSSFWorkbook(fis);
            } catch (IOException e) {
            	LOG.debug(".XLSX 로딩오류");
                throw new RuntimeException(e.getMessage(), e);
            }
        }
        
        return wb;
        
    }
	/** [엑셀업로드 메서드]
     * [설명] Cell에 해당하는 Column Name을 가젼온다(A,B,C..)
     * [설명] 만약 Cell이 Null이라면 int cellIndex의 값으로
     * [설명] Column Name을 가져온다.
     * 
	 * @Author "Kim Seon Ho"
	 * @Date 2017. 11. 24.
	 */
    public String ExcelCellRefGetName(Cell cell, int cellIndex) {
        int cellNum = 0;
        if(cell != null) {
            cellNum = cell.getColumnIndex();
        }
        else {
            cellNum = cellIndex;
        }
        return CellReference.convertNumToColString(cellNum);
    }
    
	/** [엑셀업로드 메서드]
     * [설명] Cell에 해당하는 Column Name을 가젼온다(A,B,C..)
     * [설명] 만약 Cell이 Null이라면 int cellIndex의 값으로
     * [설명] Column Name을 가져온다.
     * 
	 * @Author "Kim Seon Ho"
	 * @Date 2017. 11. 24.
	 */
    public String ExcelCellRefGetValue(Cell cell) throws NullPointerException{
        String value = "";
        
        String bgCheck = ""+cell.getCellStyle().getFillBackgroundColorColor();
    	if(colMapping == null && bgCheck.contains(validationColor)){
    		valiColList.add(cellName);
		}
    	
        //각 쎌의 값을 가져와 Type에 따라 + '' 하여 String으로 변환, 소수점 -> 정수표현
        switch(cell.getCellType()) {
        //수식을 그대로 가져올때
            case Cell.CELL_TYPE_FORMULA :
//                value = cell.getCellFormula();
                value = cell.getStringCellValue();
                break;
            case Cell.CELL_TYPE_NUMERIC :
                value = (int)cell.getNumericCellValue() + "";
                break;
                
            case Cell.CELL_TYPE_STRING :
                value = cell.getStringCellValue();
                break;
            
            case Cell.CELL_TYPE_BOOLEAN :
                value = cell.getBooleanCellValue() + "";
                break;
           
            case Cell.CELL_TYPE_BLANK :
                if(colMapping != null){
            		for(int i = 0; i < valiColList.size(); i++){
            			if(valiColList.get(i).equals(cellName)){
            				throw new NullPointerException();
            			}
            		}
                }
                break;
            
            case Cell.CELL_TYPE_ERROR :
                value = cell.getErrorCellValue() + "";
                break;
            default:
                value = cell.getStringCellValue();
        }
        return value;
    }
    
    public Integer getExDataMap(String key) {
		return exDataMap.get(key);
	}
	public void setExDataMap(String key, Integer value) {
		this.exDataMap.put(key, value);
	}
	public Map<String, String> getColMapping() {
		return colMapping;
	}
	public void setColMapping(Map<String, String> colMapping) {
		this.colMapping = colMapping;
	}
}
