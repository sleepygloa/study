이제는 JSP 개발시 MVC 패턴으로 작업하는게 당연시 되고있다. MVC패턴이란 화면에 보여줄 view 에 대한 작업, DB에서 조회 혹은 DB에 저장할 내용을 중간에 가공, 처리하는 비즈니스로직, DB에 연결하는 DAO 작업까지 JSP에서 다 하던걸 패턴화 시켜 분리하여 개발하는것인데 각각의 역할에 따라 파일들을 분리해서 작업하는것이다.
그렇게 하는 이유는 소스를 분리함으로서 각 소스의 목적이 명확해 지고 유지보수하는데 있어서 용이하기 때문이다.

MVC 패턴으로 개발하고자하면 자연스레 한 페이지에 5개의 파일이 생성되는데 JSP, Controller, DTO, Service, DAO 이다. 오늘 포스팅할 내용은 이 파일들 중 Service에 관한것이다. 

오랜시간 궁금했던 것
Service 에 대해선 항상 개인적으로 궁금하게 생각하던점이 하나 있었다. 거의 대부분의 프로젝트가 service 는 인터페이스로 생성하고 serviceImple이라는 구현객체를 생성해서 사용하고있던것이다. 물론 앞선 객체지향설계원칙에 대한 포스팅이나 DI에 대한 포스팅들을 바탕으로 생각했을때 인터페이스로 사용했을때의 장점을 모르는것은 아니나, 어차피 인터페이스와 구현클래스간의 관계가 1:1로 구성되게 되어 실질적으로 인터페이스 사용에 대한 이점을 전혀 가져가지못하게 되는데 왜 당연하다는듯이 이런식으로 구성을 하는지에 대한 궁금증이 항상 있었다.

그래서 주변 개발자들에게 물어보기도했으나 대부분 '다 이렇게 하던데' 정도의 답변이 돌아왔고 명확하게 설명해주는 경우를 볼수없었다. 또한 인터넷에 검색을 해봐도 나같은 궁금증을 가진 개발자가 자신의 생각을 적어놓은 글들만 있고 명확한 설명은 찾기가 힘들었다(내가 검색을 잘 못한탓도 있겠지만 내 수준에 이해하기힘든 글들도 많았다.). 그래서 궁금증을 시원하게 코풀듯 풀진 못하고 그냥 가슴한구석에 찜찜하게 남아있었는데 요근래 길을 걷다가 왜 그렇게 하는지에 대한 나만의 해답을 찾은듯하여 블로그에 남긴다. 물론 내가 검색해서 봤었던 여타 블로그들과 마찬가지로 나도 내 생각을 적는것이다.

잘못된 객체지향적 코딩
일단 내가 접해봤던(그리고 아마 그 외에도 상당수의 프로젝트들이) 프로젝트들은 전부 객체지향을 살려 디자인패턴을 도입하고 객체들간의 역할을 분리하여 객체들간의 협력으로 문제를 해결하는 식의 코딩을 진행하진 않았다. MVC패턴으로 개발한답시고 JSP, Controller, Model은 구분했지만 Service 클래스의 한 메서드 내에서 모든 비즈니스 로직이 진행되는 transaction script 형식의 코딩을 진행했다. 잘 생각해보면 자바는 객체지향언어라는 장점이 있다고 누누히 배워왔지만 정작 실제 현장에서는 C로 함수짜듯 절차지향적 코딩을 해왔다는 점이다. 사실상 우리에게 필요한건 Service 클래스내의 비즈니스로직을 처리하는 1개의 메서드일 뿐이고 그럼에도 불구하고 굳이 Service를 클래스로 만들고 객체를 생성해서 처리하는 이유는 그저 프로젝트에 도입된 언어가 자바이고, 자바는 메서드를 가지려면 무조건 클래스가 있어야했기때문인 것이다. 그렇게 개발을 하다보니 추가적인 요구사항, 혹은 수정사항이 들어오면 이 코드를 확장하여 개발하는것보다는 단순히 그 메서드에 if문을 추가하고, 혹은 소스 일부분을 주석처리하고 새로운 코드로 채우는 리팩토링이 절실한 코드였던 것이다.

MVC 패턴에서 Service Model 의 역할
MVC 패턴의 핵심은 View는 자신이 요청할 Controller만 알고있으면 되고, Controller는 화면에서 넘어오는 매개변수들을 이용해 Service 객체를 호출하는 역할을 한다. Service 는 불필요하게 Http 통신을 위한 HttpServlet을 상속 받을 필요도 없는 순수한 자바 객체로 구성된다(그렇기에 Service 에 request나 response와 같은 객체를 매개변수로 받아선 안된다. 그걸 사용해야하는 작업은 컨트롤러에서 해야한다.). 그렇기에 자신을 어떤 컨트롤러가 호출하든 상관없이 필요한 매개변수만 준다면 자신의 비즈니스로직을 처리하게된다. 즉 모듈화를 통해 어디서든 재사용이 가능한 클래스파일이라는 뜻이다. 단순 Web 기반이 아니라 추후 native app 으로 view단이 변경되더라도 Service는 view에 종속적인 코드가 없기때문에 그대로 재사용 할 수 있어야 한다. 그리고 추가적인 요청사항이 들어오면 기존 소스를 수정하는게 아니라 기존 service 인터페이스를 구현한 다른 클래스를 구현해 그 객체를 사용하게끔 하는것이다. OCP에 입각한 변화에는 닫혀있고 확장에는 열려있는 구조로 만들어야한다는 것이다.

결론
그렇기 때문에 Service를 인터페이스로 구성했던것이 아닐까 생각한다. 비즈니스 로직을 처리하는 모델은 요청사항에 따라 언제든 변할수있는 부분이었고 변화에 대응하기위해 확장을 염두하여 인터페이스로 구성했던것이다. 그런데 어디서부터 잘못된건지 Service를 인터페이스로 만들었던건 관례로 굳어지게 되었는데 개발은 transaction script 형식으로 진행하다보니 관례는 관례대로 남고 애초에 그렇게 하고자했던 이유는 사라져버리게 된것이다. 그래서 내가 내린 결론은 한 메서드에서 모든 역할을 다하는 이런 절차지향적 코딩에서는 사실 Service를 굳이 인터페이스로 할필요는 없다는 것이다. 물론 '그러니까 인터페이스 만들지말자' 보다는 애초에 인터페이스를 만들었던 이유를 잘 살리는게 바람직하지 않을까 생각하고, 나같은 궁금증을 가졌던 사람들에게 조금이나마 도움이 되는 글이었으면 좋겠다.


출처: http://multifrontgarden.tistory.com/97 [우리집앞마당]
